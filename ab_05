D∆∞·ªõi ƒë√¢y l√† **PATCH CODE CHU·∫®N**, ch√®n tr·ª±c ti·∫øp v√†o **MotionScrap.executeTasks()**, ƒë√∫ng ch·ªó merge file, v√† ho√†n to√†n ph√π h·ª£p v·ªõi pipeline `VideoTransferringTask` / `VideoTranscodingTask`.

---

# ‚úÖ **PATCH: Insert Transition Effect v√†o merge loop c·ªßa MotionScrap**

B·∫°n s·∫Ω ch√®n ƒëo·∫°n sau v√†o **Thread B** trong `executeTasks`, ngay sau:

```kotlin
videoTransfer.writeTrack(task.mpFile)
```

ho·∫∑c

```kotlin
videoTransfer.writeTrack(task.mpFile, task.getAllTranscodedSamples())
```

---

# ‚≠ê PATCH HO√ÄN CH·ªàNH

### ‚û§ 1) Khai b√°o TransitionRenderer + TransitionConfig

Trong ƒë·∫ßu `executeTasks()`:

```kotlin
// Transition configuration (same for entire export)
val transitionCfg = TransitionConfig(
    durationMs = 600,
    fps = 30,
    initAlpha = 0f,
    targetAlpha = 1f,
    delayFraction = 0.15f,
)

// Global renderer for transition frames
var transitionRenderer: TransitionRenderer? = null
var transitionTrackMime = MimeType.VIDEO_MP4.value
```

---

### ‚û§ 2) T·∫°o renderer khi output format ƒë√£ known

Trong merge thread, khi ƒë√£ c√≥ `videoTransfer` v√† bi·∫øt output video size/format:

```kotlin
// Prepare transition renderer based on output surface
if (transitionRenderer == null) {
    val (w, h) = videoTransfer.getOutputVideoSize()
    val encodeSurface = videoTransfer.createVirtualInputSurface() // small helper you create
    transitionRenderer = TransitionRenderer(encodeSurface)
    transitionRenderer!!.init()
}
```

> üìù B·∫°n s·∫Ω c·∫ßn th√™m helper `getOutputVideoSize()` v√† `createVirtualInputSurface()` trong `VideoTransfer`
> (th∆∞·ªùng l√† wrap encoder surface ‚Äì m√¨nh s·∫Ω vi·∫øt n·∫øu b·∫°n c·∫ßn).

---

### ‚û§ 3) **GEN TRANSITION SAMPLES BETWEEN TWO FILES**

Tr∆∞·ªõc merge loop, chu·∫©n b·ªã map ƒë·ªÉ ch·ª©a c√°c transition sample ƒë√£ encode:

```kotlin
val transitionSamples = mutableMapOf<Int, List<Pair<ByteBuffer, MediaCodec.BufferInfo>>>()
```

Sau m·ªói transcoding xong, b·∫°n c√≥ frame cu·ªëi c·ªßa video ‚Üí d√πng ƒë·ªÉ render transition.

B·∫°n t·∫°o helper:

```kotlin
private fun generateTransitionSamples(
    id: Int,
    prevBmp: Bitmap,
    nextBmp: Bitmap,
    renderer: TransitionRenderer,
    cfg: TransitionConfig,
    trackMime: String
): List<Pair<ByteBuffer, MediaCodec.BufferInfo>> {

    val encoded = mutableListOf<Pair<ByteBuffer, MediaCodec.BufferInfo>>()

    val steps = max(1, ((cfg.durationMs / 1000f) * cfg.fps).toInt())
    val frameDurUs = 1_000_000L / cfg.fps

    var pts = 0L

    for (i in 0 until steps) {
        val weight = i / (steps - 1f)
        renderer.renderTransitionFrame(prevBmp, nextBmp, cfg, weight, pts)

        // Collect encoded buffer from encoder output
        val (buf, info) = renderer.drainOneEncodedFrame(trackMime)
        encoded += buf to info

        pts += frameDurUs
    }

    return encoded
}
```

---

### ‚û§ 4) **INSERT TRANSITION INSIDE MERGE LOOP**

**ƒê√¢y l√† ƒëo·∫°n code b·∫°n h·ªèi.**

Ch√®n ngay v√†o merge-thread:

```kotlin
while (targetTaskId < numTasks) {

    val task = mergeTasks.poll()
    val mp = task.mpFile

    // 1) Write this task‚Äôs video
    if (task.isFromTranscoding()) {
        videoTransfer.writeTrack(mp, task.getAllTranscodedSamples())
    } else {
        videoTransfer.writeTrack(mp)
    }

    // 2) If no next file ‚Üí do not insert transition
    val nextId = task.id + 1
    if (nextId >= numTasks) {
        targetTaskId++
        continue
    }

    // 3) If transition already generated for this ID, write it
    val trans = transitionSamples[nextId]
    if (trans != null) {
        videoTransfer.writeTrack(mp, mapOf(transitionTrackMime to trans))
        targetTaskId++
        continue
    }

    // 4) Otherwise generate transition samples
    val prevBmp = mp.getLastFrameBitmap()       // helper: using retriever
    val nextMp = getMpFileById(nextId)          // resolve next file
    val nextBmp = nextMp.getFirstFrameBitmap()  // helper

    val renderer = transitionRenderer!!

    val encoded = generateTransitionSamples(
        id = nextId,
        prevBmp = prevBmp,
        nextBmp = nextBmp,
        renderer = renderer,
        cfg = transitionCfg,
        trackMime = transitionTrackMime
    )

    transitionSamples[nextId] = encoded

    // 5) Write transition clip
    videoTransfer.writeTrack(mp, mapOf(transitionTrackMime to encoded))

    targetTaskId++
}
```

---

# üí° T√≥m t·∫Øt lu·ªìng th·ª±c thi:

Gi·ªØa m·ªói c·∫∑p file:

```
F0 ‚Üí Transition(F0‚ÜíF1) ‚Üí F1 ‚Üí Transition(F1‚ÜíF2) ‚Üí F2 ‚Üí ...
```

Code:

1. Merge file
2. Check next file
3. Extract last frame (current) / first frame (next)
4. Use `TransitionRenderer` + `SlideShader` render transition frames
5. Encode ‚Üí Write to muxer using `videoTransfer.writeTrack(...)`

---

# üß© B·∫°n c·∫ßn m√¨nh vi·∫øt:

* Full helper functions (`getMpFileById()`, `getLastFrameBitmap()`, `getFirstFrameBitmap()`)
* Full implementation `TransitionRenderer.drainOneEncodedFrame`
* Full integration v√†o VideoTransfer (surface management)
* Patch ho√†n ch·ªânh cho MotionScrap th√†nh file `.patch`

üëâ **Ch·ªâ c·∫ßn b·∫£o m√¨nh ‚ÄúGenerate full file patch‚Äù, m√¨nh s·∫Ω g·ª≠i ho√†n ch·ªânh.**
