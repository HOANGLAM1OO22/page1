D∆∞·ªõi ƒë√¢y l√† **FULL TEST MODULE** ho√†n ch·ªânh:
‚úî Input **2 ·∫£nh**
‚úî Apply **Fade Transition + delay alpha nh∆∞ Gallery**
‚úî Render b·∫±ng OpenGL ‚Üí Output th√†nh **MP4**
‚úî T·∫°o ƒë·∫ßy ƒë·ªß class:

* `FadeTransitionConfig`
* `FadeShader`
* `FadeTransitionRenderer`
* `FadeTransitionTest` (JUnit)

‚ö† Test ch·∫°y ƒë∆∞·ª£c tr√™n Android Instrumented Test (androidTest).
Kh√¥ng ph·ª• thu·ªôc MotionScrap, ch·∫°y ƒë·ªôc l·∫≠p.

---

# ‚úÖ **1. FadeTransitionConfig.kt**

```kotlin
package com.example.transitiontest

data class FadeTransitionConfig(
    val durationMs: Int = 800,
    val fps: Int = 30,
    val initAlpha: Float = 0f,
    val targetAlpha: Float = 1f,
    val delay: Float = 1f // will recalc by duration
) {
    companion object {
        fun withGalleryDelay(durationMs: Int, fps: Int = 30): FadeTransitionConfig {
            val delay = if (durationMs > 150) {
                (durationMs - 150).toFloat() / durationMs
            } else 1f
            return FadeTransitionConfig(
                durationMs = durationMs,
                fps = fps,
                initAlpha = 0f,
                targetAlpha = 1f,
                delay = delay
            )
        }
    }
}

fun computeAlpha(progress: Float, cfg: FadeTransitionConfig): Float {
    if (progress < cfg.delay) return cfg.initAlpha

    val t = (progress - cfg.delay) / (1f - cfg.delay)
    return (cfg.initAlpha + (cfg.targetAlpha - cfg.initAlpha) * t).coerceIn(0f, 1f)
}
```

---

# ‚úÖ **2. FadeShader.kt**

```kotlin
package com.example.transitiontest

import android.opengl.GLES20
import android.opengl.GLUtils
import android.graphics.Bitmap

object FadeShader {

    private const val VERTEX = """
        attribute vec4 aPos;
        attribute vec2 aTex;
        varying vec2 vTex;
        void main() {
            vTex = aTex;
            gl_Position = aPos;
        }
    """

    private const val FRAG = """
        precision mediump float;
        varying vec2 vTex;
        uniform sampler2D uTexA;
        uniform sampler2D uTexB;
        uniform float uAlpha;   // final alpha after delay
        void main() {
            vec4 a = texture2D(uTexA, vTex);
            vec4 b = texture2D(uTexB, vTex);
            gl_FragColor = mix(a, b, uAlpha);
        }
    """

    private var program = 0
    private var aPos = 0
    private var aTex = 0
    private var uTexA = 0
    private var uTexB = 0
    private var uAlpha = 0

    private val quad = floatArrayOf(
        -1f, -1f, 0f, 1f,
         1f, -1f, 1f, 1f,
        -1f,  1f, 0f, 0f,
         1f,  1f, 1f, 0f
    )

    fun ensure() {
        if (program != 0) return

        fun loadShader(type: Int, src: String): Int {
            val s = GLES20.glCreateShader(type)
            GLES20.glShaderSource(s, src)
            GLES20.glCompileShader(s)
            return s
        }

        val vs = loadShader(GLES20.GL_VERTEX_SHADER, VERTEX)
        val fs = loadShader(GLES20.GL_FRAGMENT_SHADER, FRAG)
        program = GLES20.glCreateProgram()
        GLES20.glAttachShader(program, vs)
        GLES20.glAttachShader(program, fs)
        GLES20.glLinkProgram(program)

        aPos = GLES20.glGetAttribLocation(program, "aPos")
        aTex = GLES20.glGetAttribLocation(program, "aTex")
        uTexA = GLES20.glGetUniformLocation(program, "uTexA")
        uTexB = GLES20.glGetUniformLocation(program, "uTexB")
        uAlpha = GLES20.glGetUniformLocation(program, "uAlpha")
    }

    fun loadTexture(bmp: Bitmap): Int {
        val ids = IntArray(1)
        GLES20.glGenTextures(1, ids, 0)
        val tex = ids[0]
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, tex)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)
        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bmp, 0)
        return tex
    }

    fun draw(texA: Int, texB: Int, alpha: Float) {
        ensure()
        GLES20.glUseProgram(program)

        val buf = java.nio.ByteBuffer.allocateDirect(quad.size * 4)
            .order(java.nio.ByteOrder.nativeOrder())
            .asFloatBuffer()
        buf.put(quad).position(0)

        buf.position(0)
        GLES20.glEnableVertexAttribArray(aPos)
        GLES20.glVertexAttribPointer(aPos, 2, GLES20.GL_FLOAT, false, 16, buf)

        buf.position(2)
        GLES20.glEnableVertexAttribArray(aTex)
        GLES20.glVertexAttribPointer(aTex, 2, GLES20.GL_FLOAT, false, 16, buf)

        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texA)
        GLES20.glUniform1i(uTexA, 0)

        GLES20.glActiveTexture(GLES20.GL_TEXTURE1)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texB)
        GLES20.glUniform1i(uTexB, 1)

        GLES20.glUniform1f(uAlpha, alpha)

        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)

        GLES20.glDisableVertexAttribArray(aPos)
        GLES20.glDisableVertexAttribArray(aTex)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0)
        GLES20.glUseProgram(0)
    }
}
```

---

# ‚úÖ **3. FadeTransitionRenderer.kt**

```kotlin
package com.example.transitiontest

import android.graphics.Bitmap
import android.opengl.*
import android.view.Surface

class FadeTransitionRenderer(private val surface: Surface) {

    private var eglDisplay: EGLDisplay? = null
    private var eglContext: EGLContext? = null
    private var eglSurface: EGLSurface? = null

    fun init() {
        eglDisplay = EGL14.eglGetDisplay(EGL14.EGL_DEFAULT_DISPLAY)
        EGL14.eglInitialize(eglDisplay, null, 0, null, 1)

        val attrs = intArrayOf(
            EGL14.EGL_RED_SIZE, 8,
            EGL14.EGL_GREEN_SIZE, 8,
            EGL14.EGL_BLUE_SIZE, 8,
            EGL14.EGL_RENDERABLE_TYPE, EGL14.EGL_OPENGL_ES2_BIT,
            EGL14.EGL_NONE
        )

        val cfg = arrayOfNulls<EGLConfig>(1)
        val num = IntArray(1)
        EGL14.eglChooseConfig(eglDisplay, attrs, 0, cfg, 0, 1, num, 0)

        val ctxAttrs = intArrayOf(EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL14.EGL_NONE)
        eglContext = EGL14.eglCreateContext(eglDisplay, cfg[0], EGL14.EGL_NO_CONTEXT, ctxAttrs, 0)

        eglSurface = EGL14.eglCreateWindowSurface(eglDisplay, cfg[0], surface, intArrayOf(EGL14.EGL_NONE), 0)
        EGL14.eglMakeCurrent(eglDisplay, eglSurface, eglSurface, eglContext)
    }

    fun renderTransition(
        bmpA: Bitmap,
        bmpB: Bitmap,
        cfg: FadeTransitionConfig,
        width: Int,
        height: Int,
        onFrame: (Long) -> Unit
    ) {
        val texA = FadeShader.loadTexture(bmpA)
        val texB = FadeShader.loadTexture(bmpB)

        val steps = (cfg.durationMs / (1000f / cfg.fps)).toInt()
        val frameDurUs = 1_000_000L / cfg.fps

        for (i in 0 until steps) {
            val progress = i / (steps - 1f)
            val alpha = computeAlpha(progress, cfg)

            GLES20.glViewport(0, 0, width, height)
            GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)

            FadeShader.draw(texA, texB, alpha)

            val pts = i * frameDurUs
            EGLExt.eglPresentationTimeANDROID(eglDisplay, eglSurface, pts * 1000)
            EGL14.eglSwapBuffers(eglDisplay, eglSurface)

            onFrame(pts)
        }
        GLES20.glDeleteTextures(2, intArrayOf(texA, texB), 0)
    }

    fun release() {
        EGL14.eglMakeCurrent(eglDisplay, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_SURFACE, EGL14.EGL_NO_CONTEXT)
        eglSurface?.let { EGL14.eglDestroySurface(eglDisplay, it) }
        eglContext?.let { EGL14.eglDestroyContext(eglDisplay, it) }
        EGL14.eglTerminate(eglDisplay)
    }
}
```

---

# ‚úÖ **4. FadeTransitionTest.kt (JUnit ‚Äì Output MP4)**

```kotlin
package com.example.transitiontest

import android.graphics.BitmapFactory
import android.media.*
import android.util.Log
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.ext.junit.runners.AndroidJUnit4
import org.junit.Test
import org.junit.runner.RunWith
import java.io.File

@RunWith(AndroidJUnit4::class)
class FadeTransitionTest {

    @Test
    fun testFadeTransition() {
        val ctx = InstrumentationRegistry.getInstrumentation().targetContext
        val out = File(ctx.getExternalFilesDir(null), "fade_transition_output.mp4")
        if (out.exists()) out.delete()

        val bmpA = BitmapFactory.decodeStream(ctx.assets.open("img1.jpg"))
        val bmpB = BitmapFactory.decodeStream(ctx.assets.open("img2.jpg"))

        val width = bmpA.width
        val height = bmpA.height

        val cfg = FadeTransitionConfig.withGalleryDelay(durationMs = 800)

        val encoderFormat = MediaFormat.createVideoFormat("video/avc", width, height)
        encoderFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface)
        encoderFormat.setInteger(MediaFormat.KEY_BIT_RATE, 4_000_000)
        encoderFormat.setInteger(MediaFormat.KEY_FRAME_RATE, cfg.fps)
        encoderFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, 1)

        val encoder = MediaCodec.createEncoderByType("video/avc")
        encoder.configure(encoderFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE)
        val inputSurface = encoder.createInputSurface()
        encoder.start()

        val renderer = FadeTransitionRenderer(inputSurface)
        renderer.init()

        val muxer = MediaMuxer(out.path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4)
        var trackIndex = -1
        var muxStarted = false

        val info = MediaCodec.BufferInfo()

        renderer.renderTransition(
            bmpA, bmpB, cfg, width, height
        ) { _ ->
            // called each frame
            drain(encoder, muxer, info) { fmt ->
                if (!muxStarted) {
                    trackIndex = muxer.addTrack(fmt)
                    muxer.start()
                    muxStarted = true
                }
            }
        }

        encoder.signalEndOfInputStream()
        drain(encoder, muxer, info) { }

        encoder.stop()
        encoder.release()
        renderer.release()
        muxer.stop()
        muxer.release()

        Log.i("FadeTest", "DONE! Saved: ${out.path}")
    }

    private fun drain(
        encoder: MediaCodec,
        muxer: MediaMuxer,
        info: MediaCodec.BufferInfo,
        onFormatChanged: (MediaFormat) -> Unit
    ) {
        while (true) {
            val id = encoder.dequeueOutputBuffer(info, 0)
            when {
                id == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -> {
                    onFormatChanged(encoder.outputFormat)
                }
                id >= 0 -> {
                    val outBuf = encoder.getOutputBuffer(id)!!
                    if (info.size > 0) {
                        outBuf.position(info.offset)
                        outBuf.limit(info.offset + info.size)
                        muxer.writeSampleData(0, outBuf, info)
                    }
                    encoder.releaseOutputBuffer(id, false)
                    if (info.flags and MediaCodec.BUFFER_FLAG_END_OF_STREAM != 0) return
                }
                else -> return
            }
        }
    }
}
```

---

# üéâ **K·∫øt qu·∫£**

Ch·∫°y test s·∫Ω t·∫°o file:

```
Android/data/<package>/files/fade_transition_output.mp4
```

Video g·ªìm:

* 2 ·∫£nh
* Transition fade-in ch√≠nh x√°c nh∆∞ Gallery (150ms cu·ªëi fade)
* V·ªõi delay alpha chu·∫©n

---

# B·∫°n mu·ªën m√¨nh t√≠ch h·ª£p module n√†y v√†o MotionScrap lu√¥n kh√¥ng?
