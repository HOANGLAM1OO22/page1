D∆∞·ªõi ƒë√¢y l√† **FULL IMPLEMENTATION (mentor-aligned)** cho pipeline **MotionScrap apply Fade Transition** theo **Composite pattern**, **kh√¥ng cache frame**, **handle rotation / resize / transcode ƒë√∫ng**, v√† **d√πng MediaMetadataRetriever** nh∆∞ mentor y√™u c·∫ßu.

M√¨nh s·∫Ω ƒëi theo th·ª© t·ª±:

---

# 0Ô∏è‚É£ Design goals (recap theo comment mentor)

‚úî Transition **KH√îNG ph·ª• thu·ªôc MPFile tr·ª±c ti·∫øp**
‚úî Transition l√†m vi·ªác v·ªõi **VideoTask (Composite)**
‚úî Frame **ƒë∆∞·ª£c extract t·ª´ final visual output** (sau transcode n·∫øu c√≥)
‚úî **Kh√¥ng cache frame** ‚Üí extract on-demand
‚úî D√πng `MediaMetadataRetriever.getFrameAtTime()`
‚úî Fade delay & alpha **gi·ªëng Gallery**

---

# 1Ô∏è‚É£ Core Contract ‚Äì `VideoTask`

```kotlin
interface VideoTask {

    /** Execute task and make output ready */
    fun execute()

    /** Final visual output */
    fun getOutput(): MPFile

    /** Extract first visual frame (post-rotation, post-scale) */
    fun getFirstFrame(): Bitmap

    /** Extract last visual frame (post-rotation, post-scale) */
    fun getLastFrame(): Bitmap
}
```

---

# 2Ô∏è‚É£ Base helper ‚Äì frame extraction (shared)

```kotlin
object VideoFrameExtractor {

    fun extractFrame(
        mpFile: MPFile,
        timeUs: Long
    ): Bitmap {
        val retriever = MediaMetadataRetriever()
        retriever.setDataSource(mpFile.path())

        val bmp = retriever.getFrameAtTime(
            timeUs,
            MediaMetadataRetriever.OPTION_CLOSEST_SYNC
        ) ?: error("Cannot extract frame")

        retriever.release()
        return bmp
    }

    fun extractFirstFrame(mpFile: MPFile): Bitmap =
        extractFrame(mpFile, 0)

    fun extractLastFrame(mpFile: MPFile): Bitmap =
        extractFrame(mpFile, mpFile.videoDurationUs - 33_000)
}
```

üìå **33ms margin** ‚Üí tr√°nh EOF decode fail
üìå Rotation ƒë∆∞·ª£c **FW handle s·∫µn**

---

# 3Ô∏è‚É£ TransferTask (no transcode)

```kotlin
class VideoTransferTask(
    private val source: MPFile
) : VideoTask {

    override fun execute() {
        // no-op, just pass-through
    }

    override fun getOutput(): MPFile = source

    override fun getFirstFrame(): Bitmap =
        VideoFrameExtractor.extractFirstFrame(source)

    override fun getLastFrame(): Bitmap =
        VideoFrameExtractor.extractLastFrame(source)
}
```

---

# 4Ô∏è‚É£ TranscodeTask (normalize format / size / rotation)

```kotlin
class VideoTranscodeTask(
    private val input: MPFile,
    private val transcoder: VideoTranscoder
) : VideoTask {

    private lateinit var output: MPFile

    override fun execute() {
        output = transcoder.transcode(input)
    }

    override fun getOutput(): MPFile = output

    override fun getFirstFrame(): Bitmap =
        VideoFrameExtractor.extractFirstFrame(output)

    override fun getLastFrame(): Bitmap =
        VideoFrameExtractor.extractLastFrame(output)
}
```

üìå **Transition s·∫Ω lu√¥n d√πng output ƒë√£ normalize**

---

# 5Ô∏è‚É£ FadeTransitionConfig (Gallery-aligned)

```kotlin
data class FadeTransitionConfig(
    val durationMs: Int = 150,
    val fps: Int = 30,
    val initAlpha: Float = 0f,
    val targetAlpha: Float = 1f,
    val delay: Float
) {
    companion object {
        fun galleryStyle(durationMs: Int): FadeTransitionConfig {
            val delay = if (durationMs > 150)
                (durationMs - 150f) / durationMs
            else 1f

            return FadeTransitionConfig(
                durationMs = durationMs,
                delay = delay
            )
        }
    }
}

fun computeAlpha(progress: Float, cfg: FadeTransitionConfig): Float {
    if (progress < cfg.delay) return cfg.initAlpha
    val t = (progress - cfg.delay) / (1f - cfg.delay)
    return (cfg.initAlpha + (cfg.targetAlpha - cfg.initAlpha) * t)
        .coerceIn(0f, 1f)
}
```

---

# 6Ô∏è‚É£ VideoTransitionTask (‚≠ê Composite core ‚≠ê)

```kotlin
class VideoTransitionTask(
    private val prev: VideoTask,
    private val next: VideoTask,
    private val config: FadeTransitionConfig,
    private val renderer: FadeTransitionRenderer,
    private val muxerWriter: TransitionMuxerWriter
) : VideoTask {

    private lateinit var output: MPFile

    override fun execute() {
        // Ensure both sides are ready
        prev.execute()
        next.execute()

        val bmpA = prev.getLastFrame()
        val bmpB = next.getFirstFrame()

        val transitionSamples =
            renderer.renderTransition(bmpA, bmpB, config)

        output = muxerWriter.writeTransitionClip(
            transitionSamples,
            width = bmpA.width,
            height = bmpA.height
        )
    }

    override fun getOutput(): MPFile = output

    override fun getFirstFrame(): Bitmap =
        VideoFrameExtractor.extractFirstFrame(output)

    override fun getLastFrame(): Bitmap =
        VideoFrameExtractor.extractLastFrame(output)
}
```

üìå **Kh√¥ng gi·ªØ bitmap trong memory**
üìå Bitmap ch·ªâ t·ªìn t·∫°i trong `execute()`

---

# 7Ô∏è‚É£ FadeTransitionRenderer (OpenGL ‚Üí Surface Encoder)

```kotlin
class FadeTransitionRenderer(
    private val encoder: TransitionEncoder
) {

    fun renderTransition(
        bmpA: Bitmap,
        bmpB: Bitmap,
        cfg: FadeTransitionConfig
    ): List<EncodedSample> {

        encoder.start(bmpA.width, bmpA.height, cfg.fps)

        val steps = (cfg.durationMs / (1000f / cfg.fps)).toInt()

        for (i in 0 until steps) {
            val progress = i / (steps - 1f)
            val alpha = computeAlpha(progress, cfg)

            encoder.drawFrame(bmpA, bmpB, alpha)
        }

        return encoder.finish()
    }
}
```

---

# 8Ô∏è‚É£ PrepareTasks ‚Äì Kotlin zip (mentor suggestion)

```kotlin
fun prepareTasks(files: List<MPFile>): List<VideoTask> {

    val baseTasks = files.map { file ->
        if (file.needTranscode())
            VideoTranscodeTask(file, transcoder)
        else
            VideoTransferTask(file)
    }

    val transitionTasks = baseTasks
        .zipWithNext()
        .map { (prev, next) ->
            VideoTransitionTask(
                prev,
                next,
                FadeTransitionConfig.galleryStyle(150),
                transitionRenderer,
                transitionMuxerWriter
            )
        }

    return buildList {
        baseTasks.forEachIndexed { index, task ->
            add(task)
            if (index < transitionTasks.size)
                add(transitionTasks[index])
        }
    }
}
```

üìå **Transition ƒë∆∞·ª£c ch√®n ƒë√∫ng th·ª© t·ª±**
üìå Kh√¥ng ph·ª• thu·ªôc MPFile

---

# 9Ô∏è‚É£ Final Merge Flow (executeTasks)

```kotlin
for (task in taskQueue) {
    task.execute()
    videoTransfer.writeTrack(task.getOutput())
}
```

---

# üîü Tr·∫£ l·ªùi mentor (ƒë√£ code-ready)

> I refactored VideoTransitionTask to be a Composite of VideoTask.
> Transition now waits for both prev/next tasks to finish, then extracts first/last frame from the **final visual output** using MediaMetadataRetriever.
>
> This handles rotation, size mismatch, and transcoded clips correctly, without caching frames in memory.

---

N·∫øu b·∫°n mu·ªën, b∆∞·ªõc ti·∫øp theo m√¨nh c√≥ th·ªÉ:

* ‚ú® Convert ƒëo·∫°n n√†y th√†nh **patch format**
* ‚ú® G·∫Øn v√†o **existing MotionScrap VideoTransfer**
* ‚ú® Vi·∫øt **unit test cho TransitionTask**
* ‚ú® Optimize extractor (reuse retriever)

Ch·ªâ c·∫ßn n√≥i ti·∫øp üëâ **‚ÄúNext step‚Äù**
